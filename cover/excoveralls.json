{"source_files":[{"coverage":[null,null,null,null,null,null,null,null,null],"name":"lib/chat.ex","source":"defmodule Chat do\n  @moduledoc \"\"\"\n  Chat keeps the contexts that define your domain\n  and business logic.\n\n  Contexts are also responsible for managing your data, regardless\n  if it comes from the database, an external API or others.\n  \"\"\"\nend"},{"coverage":[null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,1,null,null,null,null,null,0,null,null,null],"name":"lib/chat/application.ex","source":"defmodule Chat.Application do\n  # See https://hexdocs.pm/elixir/Application.html\n  # for more information on OTP Applications\n  @moduledoc false\n\n  use Application\n\n  def start(_type, _args) do\n    children = [\n      # Start the Ecto repository\n      Chat.Repo,\n      # Start the Telemetry supervisor\n      ChatWeb.Telemetry,\n      # Start the PubSub system\n      {Phoenix.PubSub, name: Chat.PubSub},\n      # Start the Endpoint (http/https)\n      ChatWeb.Endpoint\n      # Start a worker by calling: Chat.Worker.start_link(arg)\n      # {Chat.Worker, arg}\n    ]\n\n    # See https://hexdocs.pm/elixir/Supervisor.html\n    # for other strategies and supported options\n    opts = [strategy: :one_for_one, name: Chat.Supervisor]\n    Supervisor.start_link(children, opts)\n  end\n\n  # Tell Phoenix to update the endpoint configuration\n  # whenever the application is updated.\n  def config_change(changed, _new, removed) do\n    ChatWeb.Endpoint.config_change(changed, removed)\n    :ok\n  end\nend"},{"coverage":[null,null,null,null,5,null,null,null,null,null,null,null,null,null,null,2,null,null,null,5,null,null],"name":"lib/chat/message.ex","source":"defmodule Chat.Message do\n  use Ecto.Schema\n  import Ecto.Changeset\n\n  schema \"messages\" do\n    field :message, :string\n    field :name, :string\n\n    timestamps()\n  end\n\n  @doc false\n  def changeset(message, attrs) do\n    message\n    |> cast(attrs, [:name, :message])\n    |> validate_required([:name, :message])\n  end\n\n  def get_messages( limit \\\\ 20) do\n    Chat.Repo.all(Chat.Message, limit: limit)\n  end\nend"},{"coverage":[null,null,null,null,null],"name":"lib/chat/repo.ex","source":"defmodule Chat.Repo do\n  use Ecto.Repo,\n    otp_app: :chat,\n    adapter: Ecto.Adapters.Postgres\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null],"name":"lib/chat_web.ex","source":"defmodule ChatWeb do\n  @moduledoc \"\"\"\n  The entrypoint for defining your web interface, such\n  as controllers, views, channels and so on.\n\n  This can be used in your application as:\n\n      use ChatWeb, :controller\n      use ChatWeb, :view\n\n  The definitions below will be executed for every view,\n  controller, etc, so keep them short and clean, focused\n  on imports, uses and aliases.\n\n  Do NOT define functions inside the quoted expressions\n  below. Instead, define any helper function in modules\n  and import those modules here.\n  \"\"\"\n\n  def controller do\n    quote do\n      use Phoenix.Controller, namespace: ChatWeb\n\n      import Plug.Conn\n      import ChatWeb.Gettext\n      alias ChatWeb.Router.Helpers, as: Routes\n    end\n  end\n\n  def view do\n    quote do\n      use Phoenix.View,\n        root: \"lib/chat_web/templates\",\n        namespace: ChatWeb\n\n      # Import convenience functions from controllers\n      import Phoenix.Controller,\n        only: [get_flash: 1, get_flash: 2, view_module: 1, view_template: 1]\n\n      # Include shared imports and aliases for views\n      unquote(view_helpers())\n    end\n  end\n\n  def router do\n    quote do\n      use Phoenix.Router\n\n      import Plug.Conn\n      import Phoenix.Controller\n    end\n  end\n\n  def channel do\n    quote do\n      use Phoenix.Channel\n      import ChatWeb.Gettext\n    end\n  end\n\n  defp view_helpers do\n    quote do\n      # Use all HTML functionality (forms, tags, etc)\n      use Phoenix.HTML\n\n      # Import basic rendering functionality (render, render_layout, etc)\n      import Phoenix.View\n\n      import ChatWeb.ErrorHelpers\n      import ChatWeb.Gettext\n      alias ChatWeb.Router.Helpers, as: Routes\n    end\n  end\n\n  @doc \"\"\"\n  When used, dispatch to the appropriate controller/view/etc.\n  \"\"\"\n  defmacro __using__(which) when is_atom(which) do\n    apply(__MODULE__, which, [])\n  end\nend"},{"coverage":[null,null,null,null,null,5,5,5,null,0,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,1,1,1,null,null,null,null,null,null,null,null,null,5,1,1,null,5,null,null],"name":"lib/chat_web/channels/room_channel.ex","source":"defmodule ChatWeb.RoomChannel do\n  use ChatWeb, :channel\n\n  @impl true\n  def join(\"room:lobby\", payload, socket) do\n    if authorized?(payload) do\n      send(self(), :after_join)\n      {:ok, socket}\n    else\n      {:error, %{reason: \"unauthorized\"}}\n    end\n  end\n\n  # Channels can be used in a request/response fashion\n  # by sending replies to requests from the client\n  @impl true\n\n  def handle_in(\"ping\", payload, socket) do\n    {:reply, {:ok, payload}, socket}\n  end\n\n  # It is also common to receive messages from the client and\n  # broadcast to everyone in the current topic (room:lobby).\n  @impl true\n  def handle_in(\"shout\", payload, socket) do\n    Chat.Message.changeset(%Chat.Message{}, payload) |> Chat.Repo.insert()\n    broadcast socket, \"shout\", payload\n    {:noreply, socket}\n  end\n\n  # Add authorization logic here as required.\n  defp authorized?(_payload) do\n    true\n  end\n\n  def handle_info(:after_join, socket) do\n    Chat.Message.get_messages()\n    |> Enum.each(fn msg -> push(socket, \"shout\", %{\n        name: msg.name,\n        message: msg.message,\n      }) end)\n    {:noreply, socket} # :noreply\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"name":"lib/chat_web/channels/user_socket.ex","source":"defmodule ChatWeb.UserSocket do\n  use Phoenix.Socket\n\n  ## Channels\n  channel \"room:lobby\", ChatWeb.RoomChannel\n\n  # Socket params are passed from the client and can\n  # be used to verify and authenticate a user. After\n  # verification, you can put default assigns into\n  # the socket that will be set for all channels, ie\n  #\n  #     {:ok, assign(socket, :user_id, verified_user_id)}\n  #\n  # To deny connection, return `:error`.\n  #\n  # See `Phoenix.Token` documentation for examples in\n  # performing token verification on connect.\n  @impl true\n  def connect(_params, socket, _connect_info) do\n    {:ok, socket}\n  end\n\n  # Socket id's are topics that allow you to identify all sockets for a given user:\n  #\n  #     def id(socket), do: \"user_socket:#{socket.assigns.user_id}\"\n  #\n  # Would allow you to broadcast a \"disconnect\" event and terminate\n  # all active sockets and channels for a given user:\n  #\n  #     ChatWeb.Endpoint.broadcast(\"user_socket:#{user.id}\", \"disconnect\", %{})\n  #\n  # Returning `nil` makes this socket anonymous.\n  @impl true\n  def id(_socket), do: nil\nend"},{"coverage":[null,null,null,null,1,null,null],"name":"lib/chat_web/controllers/page_controller.ex","source":"defmodule ChatWeb.PageController do\n  use ChatWeb, :controller\n\n  def index(conn, _params) do\n    render(conn, \"index.html\")\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"name":"lib/chat_web/endpoint.ex","source":"defmodule ChatWeb.Endpoint do\n  use Phoenix.Endpoint, otp_app: :chat\n\n  # The session will be stored in the cookie and signed,\n  # this means its contents can be read but not tampered with.\n  # Set :encryption_salt if you would also like to encrypt it.\n  @session_options [\n    store: :cookie,\n    key: \"_chat_key\",\n    signing_salt: \"j9dmUZjD\"\n  ]\n\n  socket \"/socket\", ChatWeb.UserSocket,\n    websocket: true,\n    longpoll: false\n\n  socket \"/live\", Phoenix.LiveView.Socket, websocket: [connect_info: [session: @session_options]]\n\n  # Serve at \"/\" the static files from \"priv/static\" directory.\n  #\n  # You should set gzip to true if you are running phx.digest\n  # when deploying your static files in production.\n  plug Plug.Static,\n    at: \"/\",\n    from: :chat,\n    gzip: false,\n    only: ~w(css fonts images js favicon.ico robots.txt)\n\n  # Code reloading can be explicitly enabled under the\n  # :code_reloader configuration of your endpoint.\n  if code_reloading? do\n    socket \"/phoenix/live_reload/socket\", Phoenix.LiveReloader.Socket\n    plug Phoenix.LiveReloader\n    plug Phoenix.CodeReloader\n    plug Phoenix.Ecto.CheckRepoStatus, otp_app: :chat\n  end\n\n  plug Phoenix.LiveDashboard.RequestLogger,\n    param_key: \"request_logger\",\n    cookie_key: \"request_logger\"\n\n  plug Plug.RequestId\n  plug Plug.Telemetry, event_prefix: [:phoenix, :endpoint]\n\n  plug Plug.Parsers,\n    parsers: [:urlencoded, :multipart, :json],\n    pass: [\"*/*\"],\n    json_decoder: Phoenix.json_library()\n\n  plug Plug.MethodOverride\n  plug Plug.Head\n  plug Plug.Session, @session_options\n  plug ChatWeb.Router\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"name":"lib/chat_web/gettext.ex","source":"defmodule ChatWeb.Gettext do\n  @moduledoc \"\"\"\n  A module providing Internationalization with a gettext-based API.\n\n  By using [Gettext](https://hexdocs.pm/gettext),\n  your module gains a set of macros for translations, for example:\n\n      import ChatWeb.Gettext\n\n      # Simple translation\n      gettext(\"Here is the string to translate\")\n\n      # Plural translation\n      ngettext(\"Here is the string to translate\",\n               \"Here are the strings to translate\",\n               3)\n\n      # Domain-based translation\n      dgettext(\"errors\", \"Here is the error message to translate\")\n\n  See the [Gettext Docs](https://hexdocs.pm/gettext) for detailed usage.\n  \"\"\"\n  use Gettext, otp_app: :chat\nend"},{"coverage":[null,null,null,1,null,null,null,null,null,null,null,0,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null],"name":"lib/chat_web/router.ex","source":"defmodule ChatWeb.Router do\n  use ChatWeb, :router\n\n  pipeline :browser do\n    plug :accepts, [\"html\"]\n    plug :fetch_session\n    plug :fetch_flash\n    plug :protect_from_forgery\n    plug :put_secure_browser_headers\n  end\n\n  pipeline :api do\n    plug :accepts, [\"json\"]\n  end\n\n  scope \"/\", ChatWeb do\n    pipe_through :browser\n\n    get \"/\", PageController, :index\n  end\n\n  # Other scopes may use custom stacks.\n  # scope \"/api\", ChatWeb do\n  #   pipe_through :api\n  # end\n\n  # Enables LiveDashboard only for development\n  #\n  # If you want to use the LiveDashboard in production, you should put\n  # it behind authentication and allow only admins to access it.\n  # If your application does not have an admins-only section yet,\n  # you can use Plug.BasicAuth to set up some basic authentication\n  # as long as you are also using SSL (which you should anyway).\n  if Mix.env() in [:dev, :test] do\n    import Phoenix.LiveDashboard.Router\n\n    scope \"/\" do\n      pipe_through :browser\n      live_dashboard \"/dashboard\", metrics: ChatWeb.Telemetry\n    end\n  end\nend"},{"coverage":[null,null,null,null,null,1,null,null,null,null,1,null,null,null,null,null,null,null,1,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"name":"lib/chat_web/telemetry.ex","source":"defmodule ChatWeb.Telemetry do\n  use Supervisor\n  import Telemetry.Metrics\n\n  def start_link(arg) do\n    Supervisor.start_link(__MODULE__, arg, name: __MODULE__)\n  end\n\n  @impl true\n  def init(_arg) do\n    children = [\n      # Telemetry poller will execute the given period measurements\n      # every 10_000ms. Learn more here: https://hexdocs.pm/telemetry_metrics\n      {:telemetry_poller, measurements: periodic_measurements(), period: 10_000}\n      # Add reporters as children of your supervision tree.\n      # {Telemetry.Metrics.ConsoleReporter, metrics: metrics()}\n    ]\n\n    Supervisor.init(children, strategy: :one_for_one)\n  end\n\n  def metrics do\n    [\n      # Phoenix Metrics\n      summary(\"phoenix.endpoint.stop.duration\",\n        unit: {:native, :millisecond}\n      ),\n      summary(\"phoenix.router_dispatch.stop.duration\",\n        tags: [:route],\n        unit: {:native, :millisecond}\n      ),\n\n      # Database Metrics\n      summary(\"chat.repo.query.total_time\", unit: {:native, :millisecond}),\n      summary(\"chat.repo.query.decode_time\", unit: {:native, :millisecond}),\n      summary(\"chat.repo.query.query_time\", unit: {:native, :millisecond}),\n      summary(\"chat.repo.query.queue_time\", unit: {:native, :millisecond}),\n      summary(\"chat.repo.query.idle_time\", unit: {:native, :millisecond}),\n\n      # VM Metrics\n      summary(\"vm.memory.total\", unit: {:byte, :kilobyte}),\n      summary(\"vm.total_run_queue_lengths.total\"),\n      summary(\"vm.total_run_queue_lengths.cpu\"),\n      summary(\"vm.total_run_queue_lengths.io\")\n    ]\n  end\n\n  defp periodic_measurements do\n    [\n      # A module, function and arguments to be invoked periodically.\n      # This function must call :telemetry.execute/3 and a metric must be added above.\n      # {ChatWeb, :count_users, []}\n    ]\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,0,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,null,0,null,null,null],"name":"lib/chat_web/views/error_helpers.ex","source":"defmodule ChatWeb.ErrorHelpers do\n  @moduledoc \"\"\"\n  Conveniences for translating and building error messages.\n  \"\"\"\n\n  use Phoenix.HTML\n\n  @doc \"\"\"\n  Generates tag for inlined form input errors.\n  \"\"\"\n  def error_tag(form, field) do\n    Enum.map(Keyword.get_values(form.errors, field), fn error ->\n      content_tag(:span, translate_error(error),\n        class: \"invalid-feedback\",\n        phx_feedback_for: input_name(form, field)\n      )\n    end)\n  end\n\n  @doc \"\"\"\n  Translates an error message using gettext.\n  \"\"\"\n  def translate_error({msg, opts}) do\n    # When using gettext, we typically pass the strings we want\n    # to translate as a static argument:\n    #\n    #     # Translate \"is invalid\" in the \"errors\" domain\n    #     dgettext(\"errors\", \"is invalid\")\n    #\n    #     # Translate the number of files with plural rules\n    #     dngettext(\"errors\", \"1 file\", \"%{count} files\", count)\n    #\n    # Because the error messages we show in our forms and APIs\n    # are defined inside Ecto, we need to translate them dynamically.\n    # This requires us to call the Gettext module passing our gettext\n    # backend as first argument.\n    #\n    # Note we use the \"errors\" domain, which means translations\n    # should be written to the errors.po file. The :count option is\n    # set by Ecto and indicates we should also apply plural rules.\n    if count = opts[:count] do\n      Gettext.dngettext(ChatWeb.Gettext, \"errors\", msg, msg, count, opts)\n    else\n      Gettext.dgettext(ChatWeb.Gettext, \"errors\", msg, opts)\n    end\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,2,null,null],"name":"lib/chat_web/views/error_view.ex","source":"defmodule ChatWeb.ErrorView do\n  use ChatWeb, :view\n\n  # If you want to customize a particular status code\n  # for a certain format, you may uncomment below.\n  # def render(\"500.html\", _assigns) do\n  #   \"Internal Server Error\"\n  # end\n\n  # By default, Phoenix returns the status message from\n  # the template name. For example, \"404.html\" becomes\n  # \"Not Found\".\n  def template_not_found(template, _assigns) do\n    Phoenix.Controller.status_message_from_template(template)\n  end\nend"},{"coverage":[null,null,null],"name":"lib/chat_web/views/layout_view.ex","source":"defmodule ChatWeb.LayoutView do\n  use ChatWeb, :view\nend"},{"coverage":[null,null,null],"name":"lib/chat_web/views/page_view.ex","source":"defmodule ChatWeb.PageView do\n  use ChatWeb, :view\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,1,null,null,null,null,null,null,null,null,null,null,null,4,null,4,4,null,null,null,null,null],"name":"test/support/channel_case.ex","source":"defmodule ChatWeb.ChannelCase do\n  @moduledoc \"\"\"\n  This module defines the test case to be used by\n  channel tests.\n\n  Such tests rely on `Phoenix.ChannelTest` and also\n  import other functionality to make it easier\n  to build common data structures and query the data layer.\n\n  Finally, if the test case interacts with the database,\n  we enable the SQL sandbox, so changes done to the database\n  are reverted at the end of every test. If you are using\n  PostgreSQL, you can even run database tests asynchronously\n  by setting `use ChatWeb.ChannelCase, async: true`, although\n  this option is not recommended for other databases.\n  \"\"\"\n\n  use ExUnit.CaseTemplate\n\n  using do\n    quote do\n      # Import conveniences for testing with channels\n      import Phoenix.ChannelTest\n      import ChatWeb.ChannelCase\n\n      # The default endpoint for testing\n      @endpoint ChatWeb.Endpoint\n    end\n  end\n\n  setup tags do\n    :ok = Ecto.Adapters.SQL.Sandbox.checkout(Chat.Repo)\n\n    unless tags[:async] do\n      Ecto.Adapters.SQL.Sandbox.mode(Chat.Repo, {:shared, self()})\n    end\n\n    :ok\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,4,null,null,null,null,null,null,null,null,null,null,null,null,null,null,3,null,3,1,null,null,3,null,null],"name":"test/support/conn_case.ex","source":"defmodule ChatWeb.ConnCase do\n  @moduledoc \"\"\"\n  This module defines the test case to be used by\n  tests that require setting up a connection.\n\n  Such tests rely on `Phoenix.ConnTest` and also\n  import other functionality to make it easier\n  to build common data structures and query the data layer.\n\n  Finally, if the test case interacts with the database,\n  we enable the SQL sandbox, so changes done to the database\n  are reverted at the end of every test. If you are using\n  PostgreSQL, you can even run database tests asynchronously\n  by setting `use ChatWeb.ConnCase, async: true`, although\n  this option is not recommended for other databases.\n  \"\"\"\n\n  use ExUnit.CaseTemplate\n\n  using do\n    quote do\n      # Import conveniences for testing with connections\n      import Plug.Conn\n      import Phoenix.ConnTest\n      import ChatWeb.ConnCase\n\n      alias ChatWeb.Router.Helpers, as: Routes\n\n      # The default endpoint for testing\n      @endpoint ChatWeb.Endpoint\n    end\n  end\n\n  setup tags do\n    :ok = Ecto.Adapters.SQL.Sandbox.checkout(Chat.Repo)\n\n    unless tags[:async] do\n      Ecto.Adapters.SQL.Sandbox.mode(Chat.Repo, {:shared, self()})\n    end\n\n    {:ok, conn: Phoenix.ConnTest.build_conn()}\n  end\nend"},{"coverage":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,null,null,null,null,null,null,null,null,null,null,null,0,null,0,0,null,null,null,null,null,null,null,null,null,null,null,null,null,null,0,0,0,null,null,null,null],"name":"test/support/data_case.ex","source":"defmodule Chat.DataCase do\n  @moduledoc \"\"\"\n  This module defines the setup for tests requiring\n  access to the application's data layer.\n\n  You may define functions here to be used as helpers in\n  your tests.\n\n  Finally, if the test case interacts with the database,\n  we enable the SQL sandbox, so changes done to the database\n  are reverted at the end of every test. If you are using\n  PostgreSQL, you can even run database tests asynchronously\n  by setting `use Chat.DataCase, async: true`, although\n  this option is not recommended for other databases.\n  \"\"\"\n\n  use ExUnit.CaseTemplate\n\n  using do\n    quote do\n      alias Chat.Repo\n\n      import Ecto\n      import Ecto.Changeset\n      import Ecto.Query\n      import Chat.DataCase\n    end\n  end\n\n  setup tags do\n    :ok = Ecto.Adapters.SQL.Sandbox.checkout(Chat.Repo)\n\n    unless tags[:async] do\n      Ecto.Adapters.SQL.Sandbox.mode(Chat.Repo, {:shared, self()})\n    end\n\n    :ok\n  end\n\n  @doc \"\"\"\n  A helper that transforms changeset errors into a map of messages.\n\n      assert {:error, changeset} = Accounts.create_user(%{password: \"short\"})\n      assert \"password is too short\" in errors_on(changeset).password\n      assert %{password: [\"password is too short\"]} = errors_on(changeset)\n\n  \"\"\"\n  def errors_on(changeset) do\n    Ecto.Changeset.traverse_errors(changeset, fn {message, opts} ->\n      Regex.replace(~r\"%{(\\w+)}\", message, fn _, key ->\n        opts |> Keyword.get(String.to_existing_atom(key), key) |> to_string()\n      end)\n    end)\n  end\nend"}]}